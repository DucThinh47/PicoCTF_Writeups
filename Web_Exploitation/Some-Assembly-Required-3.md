# Some Assembly Required 3

![img](405)

Trang web:

![img](406)

Xem source code:

![img](407)

Xem nội dung file `rTEuOmSfG3.js`:

![img](408)

Làm đẹp lại nội dung:

    const _0x143f = ['exports', '270328ewawLo', 'instantiate', '1OsuamQ', 'Incorrect!', 'length', 'copy_char', 'value', '1512517ESezaM', 'innerHTML', 'check_flag', 'result', '1383842SQRPPf', '924408cukzgO', 'getElementById', '418508cLDohp', 'input', 'Correct!', '573XsMMHp', 'arrayBuffer', '183RUQBDE', '38934oMACea'];
    const _0x187e = function(_0x3075b9, _0x2ac888) {
        _0x3075b9 = _0x3075b9 - 0x11d;
        let _0x143f7d = _0x143f[_0x3075b9];
        return _0x143f7d;
    };
    (function(_0x3379df, _0x252604) {
        const _0x1e2b12 = _0x187e;
        while (!![]) {
            try {
                const _0x5e2d0a = -parseInt(_0x1e2b12(0x122)) + -parseInt(_0x1e2b12(0x12f)) + -parseInt(_0x1e2b12(0x126)) * -parseInt(_0x1e2b12(0x12b)) + -parseInt(_0x1e2b12(0x132)) + parseInt(_0x1e2b12(0x124)) + -parseInt(_0x1e2b12(0x121)) * -parseInt(_0x1e2b12(0x11f)) + parseInt(_0x1e2b12(0x130));
                if (_0x5e2d0a === _0x252604) break;
                else _0x3379df['push'](_0x3379df['shift']());
            } catch (_0x289152) {
                _0x3379df['push'](_0x3379df['shift']());
            }
        }
    }(_0x143f, 0xed04c));
    let exports;
    (async () => {
        const _0x484ae0 = _0x187e;
        let _0x487b31 = await fetch('./qCCYI0ajpD'),
            _0x5eebfd = await WebAssembly[_0x484ae0(0x125)](await _0x487b31[_0x484ae0(0x120)]()),
            _0x30f3ed = _0x5eebfd['instance'];
        exports = _0x30f3ed[_0x484ae0(0x123)];
    })();

    function onButtonPress() {
        const _0x271e58 = _0x187e;
        let _0x441124 = document[_0x271e58(0x131)](_0x271e58(0x11d))[_0x271e58(0x12a)];
        for (let _0x34c54a = 0x0; _0x34c54a < _0x441124[_0x271e58(0x128)]; _0x34c54a++) {
            exports[_0x271e58(0x129)](_0x441124['charCodeAt'](_0x34c54a), _0x34c54a);
        }
        exports[_0x271e58(0x129)](0x0, _0x441124[_0x271e58(0x128)]), exports[_0x271e58(0x12d)]() == 0x1 ? document[_0x271e58(0x131)](_0x271e58(0x12e))[_0x271e58(0x12c)] = _0x271e58(0x11e) : document[_0x271e58(0x131)](_0x271e58(0x12e))['innerHTML'] = _0x271e58(0x127);
    }

Sau khi đọc code JS này, tôi thu được đường dẫn sau `./qCCYI0ajpD`, truy cập và 1 file được tự động tải về:

![img](409)

Kiểm tra định dạng của file:

![img](410)

Là một file `Wasm (WebAssembly)`, dùng để xác định định dạng mã nhị phân di động và định dạng văn bản tương ứng cho các chương trình thực thi. 

Tôi sẽ sử dụng tool `wasm-decompile`:

![img](411)

=> Kết quả thu được:

    export memory memory(initial: 2, max: 0);

    global g_a:int = 66864;
    export global input:int = 1072;
    export global key:int = 1067;
    export global dso_handle:int = 1024;
    export global data_end:int = 1328;
    export global global_base:int = 1024;
    export global heap_base:int = 66864;
    export global memory_base:int = 0;
    export global table_base:int = 1;

    table T_a:funcref(min: 1, max: 1);

    data d_nAb416(offset: 1024) =
    "\9dn\93\c8\b2\b9A\8b\9f\90\8cb\c5\c3\95\884\c8\93\92\88?\c1\92\c7\db?\c8"
    "\9e\c7\891\c6\c5\c9\8b6\c6\c6\c0\90\00\00";
    data d_b(offset: 1067) = "\f1\a7\f0\07\ed";

    export function wasm_call_ctors() {
    }

    export function strcmp(a:int, b:int):int {
    var c:int = g_a;
    var d:int = 32;
    var e:int = c - d;
    e[6]:int = a;
    e[5]:int = b;
    var f:int = e[6]:int;
    e[4]:int = f;
    var g:int = e[5]:int;
    e[3]:int = g;
    loop L_b {
        var h:ubyte_ptr = e[4]:int;
        var i:int = 1;
        var j:int = h + i;
        e[4]:int = j;
        var k:int = h[0];
        e[11]:byte = k;
        var l:ubyte_ptr = e[3]:int;
        var m:int = 1;
        var n:int = l + m;
        e[3]:int = n;
        var o:int = l[0];
        e[10]:byte = o;
        var p:int = e[11]:ubyte;
        var q:int = 255;
        var r:int = p & q;
        if (r) goto B_c;
        var s:int = e[11]:ubyte;
        var t:int = 255;
        var u:int = s & t;
        var v:int = e[10]:ubyte;
        var w:int = 255;
        var x:int = v & w;
        var y:int = u - x;
        e[7]:int = y;
        goto B_a;
        label B_c:
        var z:int = e[11]:ubyte;
        var aa:int = 255;
        var ba:int = z & aa;
        var ca:int = e[10]:ubyte;
        var da:int = 255;
        var ea:int = ca & da;
        var fa:int = ba;
        var ga:int = ea;
        var ha:int = fa == ga;
        var ia:int = 1;
        var ja:int = ha & ia;
        if (ja) continue L_b;
    }
    var ka:int = e[11]:ubyte;
    var la:int = 255;
    var ma:int = ka & la;
    var na:int = e[10]:ubyte;
    var oa:int = 255;
    var pa:int = na & oa;
    var qa:int = ma - pa;
    e[7]:int = qa;
    label B_a:
    var ra:int = e[7]:int;
    return ra;
    }

    export function check_flag():int {
    var a:int = 0;
    var b:int = 1072;
    var c:int = 1024;
    var d:int = strcmp(c, b);
    var e:int = d;
    var f:int = a;
    var g:int = e != f;
    var h:int = -1;
    var i:int = g ^ h;
    var j:int = 1;
    var k:int = i & j;
    return k;
    }

    function copy(a:int, b:int) {
    var c:int = g_a;
    var d:int = 16;
    var e:int_ptr = c - d;
    e[3] = a;
    e[2] = b;
    var f:int = e[3];
    if (eqz(f)) goto B_a;
    var g:int = 4;
    var h:int = e[2];
    var i:int = 5;
    var j:int = h % i;
    var k:ubyte_ptr = g - j;
    var l:int = k[1067];
    var m:int = 24;
    var n:int = l << m;
    var o:int = n >> m;
    var p:int = e[3];
    var q:int = p ^ o;
    e[3] = q;
    label B_a:
    var r:int = e[3];
    var s:byte_ptr = e[2];
    s[1072] = r;
    }

=> Hàm thực hiện thao tác giải mã trên một đầu vào số nguyên nhất định bằng cách áp dụng phép toán XOR với các giá trị bắt nguồn từ mảng khóa được xác định trước.

**Khởi tạo**:
- `c:int = g_a;`: Đặt thành `(66864).cg_a`
- `d:int = 16;`: Đặt thành `16.d`
- `e:int_ptr = c - d;`: Tạo con trỏ tại địa chỉ `.e66848`

**Lưu trữ đầu vào**:
- `e[3] = a;`: Lưu trữ giá trị của trong `.ae[3]`
- `e[2] = b;`: Lưu trữ giá trị của trong `.be[2]`

**Giải mã logic**:
- Kiểm tra xem có bằng không: `.fe[3]if (eqz(f)) goto B_a`;
- Tính bằng mô đun của 5: `.je[2]var j:int = h % i`;
- Tính chỉ số chu kỳ ngược: `.var k:ubyte_ptr = g - j`;
- Lấy giá trị từ tại chỉ số này: `.d_1067var l:int = k[1067]`;
- Chuyển giá trị sang trái 24 bit và quay lại để hoàn tác tràn tiềm năng: `.var n:int = l << m; var o:int = n >> m;`
- XOR với giá trị này: `.e[3]var q:int = p ^ o; e[3] = q;`

**Lưu trữ kết quả**:
- Lưu trữ giá trị đã giải mã trong: `.s[1072]s[1072] = r;`

=> Tôi cần hiểu cách hàm sao chép giải mã dữ liệu và sau đó dịch logic này sang Python:

Tạo file `sar3.py` có nội dung như sau:

    d_1024 = "\x9dn\x93\xc8\xb2\xb9A\x8b\xc2\x90\x8bd\xc7\x9e\xc9\x88b\x95\x91\x90\xdac\xc5\x95\x95\xd82\xc4\xc5\x92\x8ee\x92\x96\x97\x8ca\xc4\x93\x92\x90\x00\x00"
    d_1067 = "\xf1\xa7\xf0\x07\xed"

    # Loop through each character in d_1024
    for i in range(len(d_1024)):
        # Get the current character from d_1024
        char_1024 = d_1024[i]
        
        # Calculate the index for d_1067 (cycling in reverse through 0 to 4)
        index_1067 = 4 - (i % 5)
        
        # Get the character from d_1067 at the calculated index
        char_1067 = d_1067[index_1067]
        
        # XOR the ASCII values of the two characters and convert back to a character
        decoded_char = chr(ord(char_1024) ^ ord(char_1067))
        
        # Print the decoded character without a newline
        print(decoded_char, end="")

Giải thích:

**Khởi tạo phân đoạn dữ liệu:**
- `d_1024`: Chuỗi này chứa thông báo được mã hóa.
- `d_1067`: Chuỗi này chứa khóa được sử dụng để giải mã.

**Lặp lại từng ký tự trong d_1024:**
- Tập lệnh lặp lại từng ký tự trong `.d_1024`

**Thực hiện hoạt động XOR:**
- Đối với mỗi ký tự trong , tập lệnh tính toán một chỉ mục để truy cập ký tự tương ứng trong `.d_1024d_1067`
- Chỉ số được tính là , trong đó là vị trí hiện tại trong vòng lặp. Điều này tạo ra một mô hình tuần hoàn ngược trên phím.` 4 - (i % 5) i`
- Sau đó, tập lệnh thực hiện thao tác XOR giữa các giá trị ASCII của ký tự hiện tại từ và ký tự từ tại chỉ mục được tính toán.`d_1024d_1067`

**Chuyển đổi và in ký tự đã giải mã:**
- Kết quả của thao tác XOR được chuyển đổi trở lại thành một ký tự.
- Ký tự được giải mã được in mà không có dòng mới, nối tất cả các ký tự được giải mã thành một dòng đầu ra duy nhất.

![img](412)


