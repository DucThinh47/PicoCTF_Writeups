# some assembly required 2
![img](241)

### Web page
![img](242)

### Solution

Xem source page: 

![img](243)

=> Tìm được file JS **Y8splx37qY.js**. Truy cập thử file này:

![img](244)

Nội dung file như sau: 

    const _0x6d8f = ['copy_char', 'value', '207aLjBod', '1301420SaUSqf', '233ZRpipt', '2224QffgXU', 'check_flag', '408533hsoVYx', 'instance', '278338GVFUrH', 'Correct!', '549933ZVjkwI', 'innerHTML', 'charCodeAt', './aD8SvhyVkb', 'result', '977AzKzwq', 'Incorrect!', 'exports', 'length', 'getElementById', '1jIrMBu', 'input', '615361geljRK'];
    const _0x5c00 = function (_0x58505a, _0x4d6e6c) {
        _0x58505a = _0x58505a - 0xc3;
        let _0x6d8fc4 = _0x6d8f[_0x58505a];
        return _0x6d8fc4;
    };
    (function (_0x12fd07, _0x4e9d05) {
        const _0x4f7b75 = _0x5c00;
        while (!![]) {
            try {
                const _0x1bb902 = -parseInt(_0x4f7b75(0xc8)) - parseInt(_0x4f7b75(0xc9)) + -parseInt(_0x4f7b75(0xcd)) + parseInt(_0x4f7b75(0xcf)) + parseInt(_0x4f7b75(0xc3)) + -parseInt(_0x4f7b75(0xc6)) * parseInt(_0x4f7b75(0xd4)) + parseInt(_0x4f7b75(0xcb)) + -parseInt(_0x4f7b75(0xd9)) parseInt(_0x4f7b75(0xc7));
                if (_0x1bb902 === _0x4e9d05) break;
                else _0x12fd07 'push';
            } catch (_0x4f8a) {
                _0x12fd07 'push';
            }
        }
    }(_0x6d8f, 0x4bb06));
    let exports;
    (async() => {
        const _0x835967 = _0x5c00;
        let _0x1adb5f = await fetch(_0x835967(0xd2))
            , _0x355961 = await WebAssembly['instantiate'](await _0x1adb5f 'arrayBuffer')
            , _0x5c0ffa = _0x355961[_0x835967(0xcc)];
        exports = _0x5c0ffa[_0x835967(0xd6)];
    })();

    function onButtonPress() {
        const _0x50ea62 = _0x5c00;
        let _0x5f4170 = document_0x50ea62(0xd8)[_0x50ea62(0xc5)];
        for (let _0x19d3ca = 0x0; _0x19d3ca < _0x5f4170['length']; _0x19d3ca++) {
            exports_0x50ea62(0xc4);
        }
        exports 'copy_char', exports_0x50ea62(0xca) == 0x1 ? document 'getElementById' [_0x50ea62(0xd0)] = _0x50ea62(0xce) : document_0x50ea62(0xd8)['innerHTML'] = _0x50ea62(0xd5);
    }

=> Trong script này có đề cập đến một script assembly: **./aD8SvhyVkb**. Thử tải script này về:

![img](245)

Sau khi tải về, kiểm tra file format thì là file **wasm**. Dùng tool **wasm2wat** để dịch ngược file ra file **.wat**:

![img](246)

Thử đọc nội dung file **.wat**:

![img](247)

=> Có 1 đoạn chuỗi khả nghi ở cuối file **xakgK\5cNs>n;jl90;9:mjn9m<0n9::0::881<00?>u\00**, có vẻ đã được mã hóa.

Thử sử dụng tool **wasm-decomplie** để xem mã giả (file **.dcmp**) của file **wasm**:

![img](248)

Đọc thử nội dung của file **.dcmp** này:

![img](249)

![img](250)

![img](251)

Hàm check_flag() chỉ để kiểm tra chuỗi nhập vào. Thử phân tích hàm copy(): 

1. Các tham số và biến: 

- a và b: Hai tham số kiểu int được truyền vào hàm. 

- g_a: Một biến toàn cục hoặc giá trị được tham chiếu từ đâu đó. 

- e: Là một con trỏ (int_ptr), có vẻ như được sử dụng như một mảng tạm thời để lưu trữ dữ liệu. 

- c - d: Được tính toán để trỏ đến một vùng nhớ khác. 

2. Hoạt động chính: 

- e[3] = a và e[2] = b: Gán giá trị a và b vào các vị trí cụ thể trong mảng tạm e. 

- if (eqz(f)) goto B_a: Nếu f (giá trị tại e[3]) là 0, thực thi nhãn B_a. 

- e[3] = g ^ h: Thực hiện phép XOR giữa g (giá trị tại e[3]) và h (có giá trị là 8). Kết quả được lưu lại vào e[3]. 

- Nhãn B_a: Nếu f là 0, nhãn B_a được thực thi và giá trị tại e[3] được ghi vào k[1072]. 

3. Hoạt động XOR: XOR (^) thường được sử dụng trong mã hóa và giải mã, vì khi XOR một giá trị hai lần với cùng một khóa, sẽ khôi phục được giá trị ban đầu: 

- (x⊕k)⊕k=x(x \oplus k) \oplus k = x(x⊕k)⊕k=x Trong đoạn mã này, giá trị tại e[3] được XOR với 8, cho thấy một thao tác biến đổi dữ liệu. Lưu dữ liệu vào k[1072]: k[1072] = j: Ghi giá trị đã qua xử lý vào một vùng nhớ hoặc mảng dữ liệu. 

- j: Ghi giá trị đã qua xử lý vào một vùng nhớ hoặc mảng dữ liệu.

=> Key để giải mã XOR là **8**.

=> Viết 1 script python để decode chuỗi:

![img](252)

**Flag: picoCTF{6f3bd18312ebf1e48f12282200948876}**



