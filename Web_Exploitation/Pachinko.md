# Pachinko

![img](387)

Truy cập trang web:

![img](388)

Đọc source code được cung cấp, tôi tìm hiểu được:
- Muốn lấy FLAG1 qua `/check`: gửi mạch `NAND` đúng để `nand_checker.bin` ghi `0x1337` về `0x1000`.
- `/flag` không khai thác nếu không có `ENV FLAG1/FLAG2`.

Request và response khi nối các node có dạng như sau:

![img](389)

Tôi thử gửi request như sau và tìm được flag:

    {"circuit":[
    {"input1":5,"input2":5,"output":1},
    {"input1":6,"input2":6,"output":2},
    {"input1":7,"input2":7,"output":3},
    {"input1":8,"input2":8,"output":4}
    ]}

![img](390)

Vì cách chấm của `nand_checker` coi node `5..8` là `4` input và node `1..4` là `4` output cần kiểm tra. Server mỗi lần gọi `/check` sẽ:
- random 4 giá trị “nhị phân 16-bit” cho input: `I1..I4 ∈ {0x0000,0xFFFF}`
- tạo outputState = `NOT(I1..I4)` để làm đáp án kỳ vọng
- chạy `nand_checker.bin` với mạch gửi; chương trình sẽ nạp `I1..I4` vào `node 5..8`, rồi đọc kết quả ở `node 1..4` và so sánh với `outputState`
- nếu khớp => ghi `0x1337` ở địa chỉ `0x1000` => API in FLAG1; nếu sai => ghi `0x3333` => `“wrong answer :(”`

Mỗi gate thực hiện `NOT A = A NAND A` và đưa thẳng kết quả về đúng 4 node `output (1..4)`:
- 1 = NOT(5) = NOT(I1)
- 2 = NOT(6) = NOT(I2)
- 3 = NOT(7) = NOT(I3)
- 4 = NOT(8) = NOT(I4)

=> `Node 1..4` giống hệt `outputState` mà server kỳ vọng, nên checker ghi `0x1337` => endpoint trả flag