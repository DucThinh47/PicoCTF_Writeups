# Java Script Kiddie

![img](391)

![img](392)

Source code trang web:

![img](393)

Từ source code, tôi suy ra được:
- Website tải `jquery-3.3.1.min.js`.
- Gọi `GET /bytes` lấy về một chuỗi số cách nhau bởi dấu cách => tách thành mảng `bytes` (mỗi phần tử là 1 byte 0–255).
- `Hàm assemble_png(u_in)` nhận một `“key”` dài `16` ký tự số (LEN = 16). Nếu không nhập đủ 16 ký tự, key mặc định là "0000...0" (16 số 0).
- Với mỗi cột `i` (0=>15), nó tính `shifter = key[i] - '0'` (tức là 0–9). Rồi nó xoay vòng theo hàng (row-rotate) dữ liệu trong cột đó:

        result[(j*16)+i] = bytes[(((j + shifter)*16) % bytes.length) + i];

    Nghĩa là: chia `bytes` thành ma trận có 16 cột, nhiều hàng. Mỗi cột bị dịch xuống (xoay tròn) shifter hàng độc lập với cột khác. Không trộn cột.

- Bóc bỏ các số 0 ở cuối `result` (strip trailing zeros).
- Base64-encode `result` và gán vào `<img id="Area">` =>
render thành PNG.

Ý tưởng là:
- Tải `/bytes`.
- Sắp `bytes` thành ma trận `R x 16`.
- Với cột `i`:
    - Tìm hàng `h` sao cho `bytes[h, i] == header[i]` (lý tưởng kiểm thêm vài byte kế tiếp: “IHDR” xuất hiện sớm ngay sau header).  
    - Đặt `key[i] = h`. (Chỉ chấp nhận 0..9 vì code giới hạn key bằng ký tự số; may mắn là h <= 9, nếu không b phải dùng nhiều ràng buộc hơn: khớp cả “IHDR” ở offset 12–15, CRC/chiều dài chunk… để suy ra tổ hợp dịch hợp lệ với h trong 0–9.)
    - Khi có key 16 chữ số, nhét vào ô input => ảnh hiện ra.

Code:
    from PIL import Image
    import itertools, io, os
    KEY_LEN = 16

    def create_png(bytes_arr, key, out_dir_path):
        if not os.path.isdir(out_dir_path):
            raise Exception("Output folder ('{}') does not exist!".format(out_dir_path))
        result = [0] * len(bytes_arr)
        for i in range(KEY_LEN):
            shifter = int(key[i])
            for j in range(len(bytes_arr) // KEY_LEN):
                result[(j * KEY_LEN) + i] = bytes_arr[(((j + shifter) * KEY_LEN) % len(bytes_arr)) + i]
        img_bytes = io.BytesIO(bytes(result))

        try:
            img = Image.open(img_bytes)
            img.save(os.path.join(out_dir_path, "{}.png".format(key)))
            print ("Key {} produces a valid PNG - Saving".format(key))
        except IOError:
            print ("Key {} produces an invalid PNG - Ignoring".format(key))


    shifters = []
    for i in range(KEY_LEN):
        shifters.append([])
    expected = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52]
    with open("bytes.txt") as f:
        bytes_arr = list(map(int, f.read().split(" ")))
        for i in range(KEY_LEN):
            for shifter in range(10):
                j = 0
                offset = (((j + shifter) * KEY_LEN) % len(bytes_arr)) + i
                if bytes_arr[offset] == expected[i]:
                    shifters[i].append(shifter)               

    for p in itertools.product(*shifters):
        key = "".join("{}".format(n) for n in p)
        create_png(bytes_arr, key, "out")

Thực thi code, tìm ra được key:

![img](394)

Nhập key vào input và tải về ảnh png thu được:

![img](395)

Dùng tool `zbarimg` để nhận diện và giải mã QR từ hình ảnh:

![img](396)
